import * as fs from "fs";
import * as path from "path";

const MODELS_DIR = path.resolve(__dirname, "../src/assets/models");
const OUTPUT_FILE = path.resolve(
  __dirname,
  "../src/app/config/model-configs.ts",
);

interface GlbNode {
  name?: string;
  mesh?: number;
  children?: number[];
}

interface GlbJson {
  nodes?: GlbNode[];
  meshes?: any[];
}

function parseGlbJson(buffer: Buffer): GlbJson | null {
  // GLB Header: magic (4) + version (4) + length (4)
  const magic = buffer.readUInt32LE(0);
  if (magic !== 0x46546c67) {
    // 'glTF'
    console.error("Invalid GLB magic number");
    return null;
  }

  // Chunk 0 Header: length (4) + type (4)
  const chunkLength = buffer.readUInt32LE(12);
  const chunkType = buffer.readUInt32LE(16);

  if (chunkType !== 0x4e4f534a) {
    // 'JSON'
    console.error("First chunk is not JSON");
    return null;
  }

  const jsonBuffer = buffer.subarray(20, 20 + chunkLength);
  const jsonStr = jsonBuffer.toString("utf-8");

  try {
    return JSON.parse(jsonStr);
  } catch (e) {
    console.error("Failed to parse JSON chunk", e);
    return null;
  }
}

function generateConfig() {
  if (!fs.existsSync(MODELS_DIR)) {
    console.error(`Models directory not found: ${MODELS_DIR}`);
    process.exit(1);
  }

  const files = fs.readdirSync(MODELS_DIR).filter((f) => f.endsWith(".glb"));
  const config: Record<
    string,
    { editableParts: { id: string; meshName: string; label: string }[] }
  > = {};

  console.log(`Scanning ${files.length} GLB files...`);

  for (const file of files) {
    const filePath = path.join(MODELS_DIR, file);
    const buffer = fs.readFileSync(filePath);
    const json = parseGlbJson(buffer);

    if (!json || !json.nodes) {
      console.warn(`Skipping ${file}: No nodes found`);
      continue;
    }

    const editableParts: { id: string; meshName: string; label: string }[] = [];

    // Find all nodes that are meshes (have a 'mesh' property)
    // We only care about named meshes
    json.nodes.forEach((node) => {
      if (node.mesh !== undefined && node.name) {
        // Simple heuristic: create a readable label and ID from the mesh name
        // e.g., "Fan_Blades" -> id: "fan-blades", label: "Fan Blades"

        const id = node.name
          .toLowerCase()
          .replace(/[^a-z0-9]+/g, "-")
          .replace(/^-|-$/g, "");
        const label = node.name
          .replace(/_/g, " ")
          .replace(/([A-Z])/g, " $1")
          .trim();

        editableParts.push({
          id,
          meshName: node.name,
          label: label,
        });
      }
    });

    if (editableParts.length > 0) {
      config[file] = { editableParts };
      console.log(`‚úÖ ${file}: Found ${editableParts.length} mesh parts`);
    } else {
      console.log(`‚ö†Ô∏è ${file}: No named meshes found`);
    }
  }

  // Ensure output directory exists
  const outputDir = path.dirname(OUTPUT_FILE);
  if (!fs.existsSync(outputDir)) {
    fs.mkdirSync(outputDir, { recursive: true });
  }

  const fileContent = `// Auto-generated by scripts/generate-model-configs.ts
// Do not edit manually.

export const MODEL_CONFIGS: Record<string, { editableParts: { id: string; meshName: string; label: string }[] }> = ${JSON.stringify(config, null, 2)};
`;

  fs.writeFileSync(OUTPUT_FILE, fileContent);
  console.log(`\nüéâ Successfully generated model configs at: ${OUTPUT_FILE}`);
}

generateConfig();
